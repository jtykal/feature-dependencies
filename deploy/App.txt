<!DOCTYPE html>
<html>
<head>
    <title>CATS-Story Dependency Schedule-1.0.7</title>
    <!--  (c) 2017 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Thu May 28 2020 18:07:46 GMT+0100 (British Summer Time) -->

    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu May 28 2020 18:07:46 GMT+0100 (British Summer Time)";
        var ARTIFACT = "";
        var BUILDER  = "nikantonelli";
        var CHECKSUM = "30546706959";
    </script>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>
    <!-- our highcharts (needed so that we can add patterns)
    <script type="text/javascript" src="/apps/2.1/lib/analytics/analytics-all.js"></script>
    -->


    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('Renderers', {

    singleton: true,

    alternateRowModifier: function(metaData, record, rowIndex, store, subDataIndex) {
        // Determine the row color so that row colors alternate anytime the primary
        // artifact changes.
        var extraCls = [subDataIndex.toLowerCase()];
        var rowItemId = record.get(Constants.ID.STORY).id;
        if (rowIndex == 0) {
            record.alternateRow = false;
        }
        else {
            var priorRowItem = store.getAt(rowIndex - 1);
            if (rowItemId != priorRowItem.get(Constants.ID.STORY).id) {
                record.alternateRow = !priorRowItem.alternateRow;
                extraCls.push(Constants.CLASS.FIRST_IN_GROUP);
            }
            else {
                record.alternateRow = priorRowItem.alternateRow;
                if (subDataIndex === Constants.ID.STORY) {
                    extraCls.push(Constants.CLASS.HIDDEN);
                }
            }
        }

        if (record.alternateRow) {
            extraCls.push(Constants.CLASS.ALTERNATE_ROW);
        }

        metaData.tdCls = metaData.tdCls + ' ' + extraCls.join(' ');

    },

    /**
     * When the Feature has been renamed, the default renderers don't create the linked
     * ID. Pull the appropriate "feature-level" portfolio item from the records and
     * use the DetailLink component to generate a link.
     */
    featureRenderer: function(metaData, record, rowIndex, store, subDataIndex, columnCfg) {
        try {
            var feature = record.get(subDataIndex).get(columnCfg.dataIndex)
            var result = Rally.nav.DetailLink.getLink({
                record: feature,
                text: feature.FormattedID
            }) + ': ' + feature._refObjectName;
        }
        catch (ex) {
            result = '';
        }
        Renderers.alternateRowModifier(metaData, record, rowIndex, store, subDataIndex);
        return result;
    }
});

/**
 * Allows us to use the default field renderers returned by
 * Rally.ui.grid.FieldColumnFactory.getColumnConfigFromField() by wrapping
 * that renderer in a function that knows how to get to the Story, Predecessor
 * and Successor objects in our custom model.
 */
Ext.override(Rally.ui.grid.CellRendererFactory, {
    createRendererFunction: function(column) {
        var renderer = this.callParent(arguments);
        return function(value, metaData, record, rowIndex, colIndex, store, view) {
            var result;
            // Now get the sub-data so the default renderer can work
            var subRecord = record;
            var subDataIndex = column.__subDataIndex;
            if (subDataIndex) {
                subRecord = record.get(subDataIndex);
            }
            if (subRecord) {
                result = renderer(value, metaData, subRecord, rowIndex, colIndex, store, view);
            }
            else {
                result = '';
            }

            // After the default renderer has run, update the tdCls (it overwrite the tdCls value)
            Renderers.alternateRowModifier(metaData, record, rowIndex, store, subDataIndex);
            return result;
        }
    }
});

Ext.define('CA.technicalservices.userutilities.FieldPicker', {
    alias: 'widget.tsfieldpickerbutton',
    extend: 'Rally.ui.Button',
    requires: [
        'Rally.ui.popover.Popover',
        'Rally.ui.Button',
        'Rally.ui.picker.FieldPicker',
        'Ext.state.Manager'
    ],
    toolTipConfig: {
        html: 'Show Columns',
        anchor: 'top'
    },
    iconCls: 'icon-add-column',

    cls: 'field-picker-btn secondary rly-small',

    alwaysSelectedValues: ['FormattedID', 'Name'], // DragAndDropRank gets added in init if Drag and Drop is enabled for the workspace in the component's context

    fieldBlackList: [],

    fieldPickerConfig: {},

    buttonConfig: {},

    modelNames: ['User'],

    rankingEnabled: false,

    //This does not show the Rank column

    constructor: function(config) {
        this.config = _.merge({}, this.config || {}, config || {});
        this.callParent([config]);
    },

    initComponent: function() {

        if (this.models) {
            this.on('click', this._createPopover, this);
            this.callParent(arguments);
            return;
        }

        if (this.context && this.modelNames && this.modelNames.length > 0) {
            Rally.data.ModelFactory.getModels({
                types: this.modelNames,
                context: this.context,
                success: function(models) {
                    this.models = models;
                },
                failure: function(failedParam) {
                    console.log('failedparam');
                },
                scope: this
            });
            this.on('click', this._createPopover, this);
        }
        else {
            this.iconCls = 'icon-none';
            var msg = "Please update the CA.technicalservices.FieldPicker configuration with modelNames and context";
            this.toolTipConfig = {
                html: '<div style="color:red;">' + msg + '</div>'
            };
            this.on('click', function() { Rally.ui.notify.Notifier.showError({ message: msg }); });
        }
        this.callParent(arguments);
    },
    getFields: function() {
        return _.union(this._fields || [], this.alwaysSelectedValues);
    },
    _getPickerConfig: function() {
        var pickerConfig;
        pickerConfig = _.extend({
            value: this._fields,
            fieldBlackList: this.fieldBlackList,
            alwaysSelectedValues: this.alwaysSelectedValues,
            context: this.context
        }, this.fieldPickerConfig);

        return pickerConfig;
    },

    _createPopover: function(btn) {
        var popoverTarget = btn.getEl();

        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: popoverTarget,
            placement: ['bottom', 'left', 'top', 'right'],
            cls: 'field-picker-popover',
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: this.getTitle(),
            listeners: {
                destroy: function() {
                    this.popover = null;
                },
                scope: this
            },
            buttons: [{
                    xtype: "rallybutton",
                    text: 'Apply',
                    cls: 'field-picker-apply-btn primary rly-small',
                    listeners: {
                        click: function() {
                            this._onApply(this.popover);
                        },
                        scope: this
                    }
                },
                {
                    xtype: "rallybutton",
                    text: 'Cancel',
                    cls: 'field-picker-cancel-btn secondary dark rly-small',
                    listeners: {
                        click: function() {
                            this.popover.close();
                        },
                        scope: this
                    }
                }
            ],
            items: [
                _.extend({
                    xtype: 'rallyfieldpicker',
                    cls: 'field-picker',
                    itemId: 'fieldpicker',
                    modelTypes: this._getModelTypes(),
                    alwaysExpanded: true,
                    width: 200,
                    emptyText: 'Search',
                    selectedTextLabel: 'Selected',
                    availableTextLabel: 'Available',
                    listeners: {
                        specialkey: function(field, e) {
                            if (e.getKey() === e.ESC) {
                                this.popover.close();
                            }
                        },
                        scope: this
                    }
                }, this._getPickerConfig())
            ]
        });
    },

    _getModelTypes: function() {
        return _.pluck(this._getModels(), 'typePath');
    },

    _getModels: function() {
        return _.reduce(this.models, function(accum, model) {
            if (model.typePath === 'artifact') {
                accum = accum.concat(model.getArtifactComponentModels());
            }
            else {
                accum.push(model);
            }
            return accum;
        }, []);
    },

    getTitle: function() {
        return 'Show Columns';
    },

    /**
     * Update the fields displayed. In grid mode this will be the columns displayed. In board mode it will be
     * the fields on the cards
     *
     * @param {String[]|Object[]} fields A list of field names to display
     * @param {Boolean} true to suspend store load if it will be triggered elsewhere
     */
    updateFields: function(fields, suspendLoad) {
        this._fields = fields;
        if (this.popover && this.popover.down('rallyfieldpicker')) {
            this.popover.down('rallyfieldpicker').setValue(fields.join(','));
        }
        this.saveState();
    },
    getState: function() {
        return {
            fields: this._fields
        };
    },
    applyState: function(state) {
        if (state) {
            this._fields = state.fields;
        }
    },
    _onApply: function(popover) {
        var fieldPicker = popover.down('rallyfieldpicker'),
            fields = _.map(fieldPicker.getValue(), function(field) {
                return field.get('name');
            });

        this.updateFields(fields);
        popover.close();

        this.fireEvent('fieldsupdated', fields);
    }
});

/* global Ext */
Ext.define('Constants', function(Constants) {
    return {
        statics: {
            DEFAULT_COLUMNS: ['FormattedID', 'Name', 'Project'],
            ARTIFACT_FETCH_FIELDS: ['Predecessors', 'Successors', 'Release', 'ReleaseStartDate', 'Iteration', 'StartDate', 'Name'],
            CLASS: {
                OK: 'ok',
                WARNING: 'warning',
                ERROR: 'error',
                UNKNOWN: 'unknown',
                ALTERNATE_ROW: 'alternate-row',
                HIDDEN: 'hidden',
                FIRST_IN_GROUP: 'first-in-group'
            },
            ID: {
                STORY: 'STORY',
                PREDECESSOR: 'PREDECESSOR',
                SUCCESSOR: 'SUCCESSOR'
            },
            LABEL: {
                UNSCHEDULED: 'Unscheduled',
                DEPENDENCY_TYPE: 'Dependency Type',
                SHOW_ALL: 'Include items with no dependencies',
                STORY: 'Story',
                PREDECESSOR: 'Predecessor(s)',
                SUCCESSOR: 'Successor(s)'
            },
            SETTING: {
                DEPENDENCY_TYPE: 'DEPENDENCY_TYPE',
                STORY: 'STORY'
            }
        }
    }
});

/* global Ext _ Rally Constants */
Ext.define('MetricsManager', function(MetricsManager) {
    return {
        statics: {
            createDependencyStore: createDependencyStore
        }
    }

    function createDependencyStore(records) {
        return _loadDependencies(records)
            .then({
                success: function(results) {
                    // Results is an array of all of the 
                    var store = Ext.create('Rally.data.custom.Store', {
                        data: results
                    });
                    return store;
                }
            });
    }

    /**
     * Returns a promise that resolves to an array of stories that are the
     * dependencies of the given stories. Each primary story has
     * has a __Predecessors and __Successors array set, and each dependency
     * has a __PrimaryStory reference set.
     */
    function _loadDependencies(records) {
        if (!records || records.length == 0) {
            return Deft.promise.Promise.when([]);
        }

        var dependentPromises = [];
        _.forEach(records, function(record) {
            var predecessorsRef = record.get('Predecessors');
            var successorsRef = record.get('Successors');
            var predecessors = [];
            if (predecessorsRef.Count > 0) {
                predecessors = record
                    .getCollection('Predecessors', {
                        limit: Infinity,
                        fetch: Rally.getApp().artifactFetchFields
                    })
                    .load();
            }
            var successors = [];
            if (successorsRef.Count > 0) {
                successors = record
                    .getCollection('Successors', {
                        limit: Infinity,
                        fetch: Rally.getApp().artifactFetchFields
                    })
                    .load()
            }

            // only include stories with no dependencies in the results if user
            // requests them
            if (Rally.getApp().showItemsWithoutDependencies || predecessorsRef.Count > 0 || successorsRef.Count > 0) {
                var result = Deft.promise.Promise.all([predecessors, successors])
                    .then({
                        scope: this,
                        success: function(results) {
                            var rows = _.zip([record], results[0], results[1]);
                            return _.map(rows, function(row) {
                                var result = {};
                                result[Constants.ID.STORY] = record;
                                result[Constants.ID.PREDECESSOR] = row[1];
                                result[Constants.ID.SUCCESSOR] = row[2];
                                return result;
                            });
                        }
                    });
                dependentPromises.push(result);
            }

        });

        // TODO (tj) sorting by primary story?
        if (dependentPromises.length == 0) {
            // If no stories found, make sure we still return a promise. .all below doesn't :(
            result = Deft.promise.Promise.when([]);
        }
        else {
            result = Deft.promise.Promise.all(dependentPromises).then({
                success: function(results) {
                    var data = _.flatten(results);
                    return data;
                }
            });
        }
        return result;
    }
});

/* global Ext MetricsManager Constants Rally _ */
Ext.define("CArABU.app.TSApp", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    defaults: { margin: 10 },
    config: {
        defaultSettings: {
            DEPENDENCY_TYPE: Constants.SETTING.STORY
        },
    },
    layout: {
        type: 'vbox',
        align: 'stretch',
    },
    items: [{
            xtype: 'container',
            layout: {
                type: 'hbox',
            },
            items: [
                { xtype: 'container', itemId: 'controlsArea' },
                { xtype: 'container', flex: 1 },
                { xtype: 'container', layout: { type: 'hbox' }, itemId: 'settingsArea' },
            ]
        },
        { xtype: 'container', itemId: 'filtersArea' },
    ],
    integrationHeaders: {
        name: "CArABU.app.TSApp"
    },
    showItemsWithoutDependencies: false,

    onTimeboxScopeChange: function(newTimeboxScope) {
        this.callParent(arguments);
        // TODO (tj) Ideally, we would just refresh the grid, but it is not clear to me how
        // to do that with a rallygridboard and preserve the timebox filter AND any existing
        // advanced filters from the filter plugin. Instead, if the page level timebox changes, just
        // relaunch the app.
        this.loadPrimaryStories(this.modelName);
    },

    initLowestPortfolioItemTypeName: function() {
        return Ext.create('Rally.data.wsapi.Store', {
            model: Ext.identityFn('TypeDefinition'),
            fetch: ['Name', 'Ordinal', 'TypePath'],
            sorters: {
                property: 'Ordinal',
                direction: 'ASC'
            },
            filters: [{
                    property: 'Creatable',
                    operator: '=',
                    value: 'true'
                },
                {
                    property: 'Parent.Name',
                    operator: '=',
                    value: 'Portfolio Item'
                }
            ]
        }).load().then({
            scope: this,
            success: function(results) {
                return results[0].get('Name');
            }
        });
    },

    showFeatureDependencies: function() {
        return this.getSetting(Constants.SETTING.DEPENDENCY_TYPE) != Constants.SETTING.STORY;
    },

    getViewType: function() {
        return this.getSetting(Constants.SETTING.DEPENDENCY_TYPE);
    },

    getLowestPortfolioItemTypeName: function() {
        return this.lowestPortfolioItemTypeName || 'Feature'
    },

    launch: function() {
        this.initLowestPortfolioItemTypeName().then({
            scope: this,
            success: function(name) {
                this.lowestPortfolioItemTypeName = name;
                this.modelName = 'hierarchicalrequirement';
                if (this.showFeatureDependencies()) {
                    this.modelName = 'portfolioitem/' + this.getLowestPortfolioItemTypeName();
                }
            }
        }).then({
            scope: this,
            success: function() {
                return this.loadModel(this.modelName);
            }
        }).then({
            scope: this,
            success: function(model) {
                this.model = model;
                this.addFilters(this.modelName);
                this.addSettingsControls();
                // Initial load of stories triggered by change handler on the filter button
                //this.loadPrimaryStories(this.modelName);
            }
        })
    },

    loadPrimaryStories: function(modelName) {
        var grid = this.down('#grid');
        if (grid) {
            grid.setLoading('Loading...');
        }
        else {
            this.setLoading('Loading...');
        }
        this.artifactFetchFields = this.getFieldNames().concat(Constants.ARTIFACT_FETCH_FIELDS);

        var filters = [];

        var timeboxScope = this.getContext().getTimeboxScope();
        if (timeboxScope) {
            filters.push(timeboxScope.getQueryFilter());
        }

        var advancedFilters = this.getFiltersFromButton();
        if (advancedFilters) {
            filters.push(advancedFilters);
        }

        Ext.create('Rally.data.wsapi.Store', {
            model: modelName,
            autoLoad: true,
            filters: filters,
            limit: Infinity,
            listeners: {
                scope: this,
                load: function(store, records) {
                    MetricsManager.createDependencyStore(records)
                        .then({
                            scope: this,
                            success: function(store) {
                                this.addGrid(store)
                                this.setLoading(false);
                            }
                        })
                }
            },
            fetch: this.artifactFetchFields
        });
    },

    addFilters: function(modelName) {
        var controlsArea = this.down('#controlsArea');

        // Add column picker first so we know what fields to fetch during artifact load
        var alwaysSelectedColumns = ['FormattedID', 'Name'];
        if (this.showFeatureDependencies()) {
            alwaysSelectedColumns.push('Release')
        }
        else {
            alwaysSelectedColumns.push('Iteration');
        }
        controlsArea.add({
            xtype: 'tsfieldpickerbutton',
            modelNames: [modelName],
            context: this.getContext(),
            stateful: true,
            stateId: this.getViewType() + 'fields', // columns specific to type of object
            alwaysSelectedValues: alwaysSelectedColumns,
            listeners: {
                fieldsupdated: function(fields) {
                    this.loadPrimaryStories(this.modelName);
                },
                scope: this
            }
        });

        // Add in-line filters
        controlsArea.add({
            xtype: 'rallyinlinefilterbutton',
            modelNames: [modelName],
            context: this.getContext(),
            stateful: true,
            stateId: this.getViewType() + 'filters', // filters specific to type of object
            listeners: {
                inlinefilterready: this.addInlineFilterPanel,
                inlinefilterchange: function(cmp) {
                    // This component fires change before it is fully added. Capture the
                    // reference to the filter button in the change handler so it can be used
                    // by loadPrimaryStories. Attempts to get to
                    // the button by using this.down('rallyinlinefilterbutton') will return null
                    // at this point.
                    this.filterButton = cmp;
                    this.loadPrimaryStories(this.modelName);
                },
                scope: this
            }
        });

    },

    addSettingsControls: function() {
        var me = this;
        var settingsArea = this.down('#settingsArea');

        settingsArea.add({
            xtype: 'rallycheckboxfield',
            fieldLabel: Constants.LABEL.SHOW_ALL,
            labelWidth: 200,
            name: 'showItemsWithoutDependencies',
            value: this.showItemsWithoutDependencies,
            listeners: {
                scope: this,
                change: function(checkbox, newValue) {
                    this.showItemsWithoutDependencies = newValue;
                    this.loadPrimaryStories(this.modelName);
                }
            }
        });

        settingsArea.add({
            xtype: 'rallybutton',
            margin: '0 10 0 10',
            text: 'Export',
            handler: function(a,b,c,d,e,f) {
                var grid = me.down('#grid');
                this.exportCSV(grid.store);
            },
            scope: me
        });
    },

    _downloadFiles: function( files ) {
        if ( files.length )
        {
            var data = files.pop();
            var format = files.pop();
            var file = files.pop();

            var href = "<a href='" + format + "," + encodeURIComponent(data) + "' download='" + file + "'></a>";

            var ml = Ext.DomHelper.insertAfter(window.document.getElementsByClassName('app')[0], href);
            ml.click();
//            ml.remove(); //Leaves them behind without this, but there is a timing issue: from click to remove.
            this._downloadFiles(files);
        }
    },

    exportCSV: function(store) {
        var data = this._exportStore(store);
        // fix: ' character was causing termination of csv file
        data = data.replace(/\'/g, " ");
        this._downloadFiles(
            [
                'depsExport.csv', 'data:text/csv;charset=utf8', data
            ]
        );

    },

    _exportStore: function(store) {
        var textOut = '';
        _.each(this.getFieldNames(), function(field) {
            textOut += field+',';
        })
        _.each(this.getFieldNames(), function(field) {
            textOut += 'Predecessor '+field+',';
        })
        _.each(this.getFieldNames(), function(field) {
            textOut += 'Successor '+field+',';
        });
        textOut = textOut.slice(0,-1)+'\n';

        var me = this;
        debugger;
        _.each(store.getData().items, function(item) {
            textOut += me._getItemCSVString(item, 'STORY');
            textOut += me._getItemCSVString(item, 'PREDECESSOR');
            textOut += me._getItemCSVString(item, 'SUCCESSOR');
            textOut = textOut.slice(0,-1)+'\n';
        });

        return textOut;
    },

    _getItemCSVString: function(item, witch) {
        var me = this;
        var retStr = '';

        var section =  item.get(witch);
        _.each(this.getFieldNames(), function(field) {
            if (section) {
                var fieldData = section.get(field);
                var details = me._getFieldTextAndEscape(fieldData);
                retStr += details;
            }
            retStr += ',';
        });
        return retStr;
    },

    _escapeForCSV: function(string) {
        string = "" + string;
        if (string.match(/,/)) {
            if (!string.match(/"/)) {
                string = '"' + string + '"';
            } else {
                string = string.replace(/,/g, ''); // comma's and quotes-- sorry, just lose the commas
            }
        }
        return string;
    },

    _getFieldText: function(fieldData) {
        var text;
        if (fieldData === null || fieldData === undefined) {
            text = '';

        // we capture object types here
        } else if (fieldData._refObjectName && !fieldData.getMonth) {
            text = fieldData._refObjectName;

        // Date types here
        } else if (fieldData instanceof Date) {
            text = Ext.Date.format(fieldData, this.dateFormat);

        //The dependencies field is a synthetic one. We identity it by the field contents
        } else if (fieldData.Count !== undefined) {
            text = fieldData.Count.toString();
        }
        /*else if (!fieldData.match) { // not a string or object we recognize...bank it out
            text = '';
        } */ else {
            var delimiter = ",",
            rowDelimiter = "\r\n",
            re = new RegExp(delimiter + '|\"|\r|\n','g'),
            reHTML = new RegExp('<\/?[^>]+>', 'g'),
            reNbsp = new RegExp('&nbsp;','ig');

            text = fieldData;
            if (reHTML.test(text)){
                text = fieldData.replace('<br>',rowDelimiter);
                text = Ext.util.Format.htmlDecode(text);
                text = Ext.util.Format.stripTags(text);
            }
            if (reNbsp.test(text)){
                text = text.replace(reNbsp,' ');
            }

            if (re.test(text)){ //enclose in double quotes if we have the delimiters
                text = text.replace(/\"/g,'\"\"');
                text = Ext.String.format("\"{0}\"",text);
            }
        }

        return text;
    },

    _getFieldTextAndEscape: function(fieldData) {
        var string  = this._getFieldText(fieldData);

        return this._escapeForCSV(string);
    },


    addInlineFilterPanel: function(panel) {
        this.down('#filtersArea').add(panel);
    },

    getFiltersFromButton: function() {
        var filters = null;
        try {
            filters = this.filterButton.getWsapiFilter()
        }
        catch (ex) {
            // Ignore if filter button not yet available
        }

        return filters;
    },

    addGrid: function(store) {
        var grid = this.down('#grid');
        if (grid) {
            this.remove(grid);
        }

        this.add({
            xtype: 'rallygrid',
            itemId: 'grid',
            flex: 1,
            //width: this.getWidth(),
            showRowActionsColumn: false,
            enableColumnHide: false,
            sortableColumns: false,
            enableEditing: false,
            rowLines: false,
            store: store,
            columnCfgs: this.getColumns(),
        })
    },

    getFieldNames: function() {
        try {
            var result = this.down('tsfieldpickerbutton').getFields() || Constants.DEFAULT_COLUMNS;
        }
        catch (ex) {
            result = Constants.DEFAULT_COLUMNS
        }
        return result;
    },

    getColumns: function() {
        return [{
                xtype: 'gridcolumn',
                text: this.showFeatureDependencies() ? this.getLowestPortfolioItemTypeName() : Constants.LABEL.STORY,
                __subDataIndex: Constants.ID.STORY, // See Overrides.js
                columns: this.getSubColumns(Constants.ID.STORY)
            },
            {
                xtype: 'gridcolumn',
                tdCls: 'group-separator',
                width: 4,
            },
            {
                xtype: 'gridcolumn',
                text: Constants.LABEL.PREDECESSOR,
                __subDataIndex: Constants.ID.PREDECESSOR, // See Overrides.js
                columns: this.getSubColumns(Constants.ID.PREDECESSOR)
            },
            {
                xtype: 'gridcolumn',
                tdCls: 'group-separator',
                width: 4,
            },
            {
                xtype: 'gridcolumn',
                text: Constants.LABEL.SUCCESSOR,
                __subDataIndex: Constants.ID.SUCCESSOR, // See Overrides.js
                columns: this.getSubColumns(Constants.ID.SUCCESSOR)
            }
        ]
    },

    getSubColumns: function(subDataIndex) {
        var selectedFieldNames = this.getFieldNames();
        var columns = _.map(selectedFieldNames, function(selectedFieldName) {
            var column;
            var columnCfg = this.getColumnConfigFromModel(selectedFieldName);
            switch (columnCfg.dataIndex) {
                case this.getLowestPortfolioItemTypeName():
                    column = {
                        xtype: 'gridcolumn',
                        text: columnCfg.modelField.displayName,
                        scope: this,
                        renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
                            return Renderers.featureRenderer(metaData, record, rowIndex, store, subDataIndex, columnCfg);
                        }
                    }
                    break;
                case 'Release':
                case 'Iteration':
                    // Color code Release and Iteration values
                    column = {
                        xtype: 'gridcolumn',
                        text: columnCfg.text,
                        scope: this,
                        renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
                            var result;
                            try {
                                switch (subDataIndex) {
                                    case Constants.ID.PREDECESSOR:
                                        result = this.predecessorIterationRenderer(record, columnCfg.dataIndex);
                                        break;
                                    case Constants.ID.SUCCESSOR:
                                        result = this.successorIterationRenderer(record, columnCfg.dataIndex);
                                        break;
                                    default:
                                        result = this.primaryIterationRenderer(record, columnCfg.dataIndex);
                                        break;
                                }
                            }
                            catch (ex) {
                                result = '';
                            }
                            // Determine the row color so that row colors alternate anytime the primary
                            // artifact changes.
                            Renderers.alternateRowModifier(metaData, record, rowIndex, store, subDataIndex);
                            return result;
                        }
                    }
                    break;
                default:
                    // All other columns use the default rendering (see Overrides.js for getting to the sub-data)
                    column = columnCfg;
            }
            column.height = 30; // Needed when a column is picked that has a two row title
            column.__subDataIndex = subDataIndex;
            column.isCellEditable = false;
            return column;
        }, this);

        return columns;
    },

    loadModel: function(modelName) {
        var deferred = new Deft.promise.Deferred;
        Rally.data.wsapi.ModelFactory.getModel({
            type: modelName,
            context: this.getContext(),
            success: function(model) {
                deferred.resolve(model);
            }
        });
        return deferred.getPromise();
    },

    getColumnConfigFromModel: function(fieldName) {
        var field = this.model.getField(fieldName);
        if (_.isUndefined(field)) {
            return null;
        }
        var builtConfig = Rally.ui.grid.FieldColumnFactory.getColumnConfigFromField(field, this.model);
        return builtConfig;
    },

    getStartDateField: function(timeboxField) {
        return timeboxField === 'Release' ? 'ReleaseStartDate' : 'StartDate';
    },

    primaryIterationRenderer: function(row, timeboxField) {
        var colorClass = Constants.CLASS.OK;
        try {
            var primaryIterationName = row.get(Constants.ID.STORY).get(timeboxField).Name;
        }
        catch (ex) {
            primaryIterationName = Constants.LABEL.UNSCHEDULED;
            colorClass = Constants.CLASS.UNKNOWN;
        }

        return this.colorsRenderer(primaryIterationName, colorClass);
    },

    predecessorIterationRenderer: function(row, timeboxField) {
        var result;
        var startDateField = this.getStartDateField(timeboxField)
        var primaryStory = row.get(Constants.ID.STORY);
        var predecessor = row.get(Constants.ID.PREDECESSOR);

        if (predecessor) {
            var colorClass = Constants.CLASS.OK;
            var primaryIteration = primaryStory.get(timeboxField);
            var predecessorIteration = predecessor.get(timeboxField);

            var predecessorIterationName;

            if (predecessorIteration && primaryIteration) {
                predecessorIterationName = predecessorIteration.Name;
                var primaryStartDate = primaryIteration[startDateField];
                var predecessorStartDate = predecessorIteration[startDateField];

                if (predecessorStartDate < primaryStartDate) {
                    // Predecessor scheduled before primary. OK
                }
                else if (predecessorStartDate == primaryStartDate) {
                    // Predecessor scheduled in same iteration as primary. Warn
                    colorClass = Constants.CLASS.WARNING;
                }
                else {
                    // Predecessor scheduled after primary (or not scheduled). Error
                    colorClass = Constants.CLASS.ERROR;
                }
            }
            else if (!predecessorIteration && primaryIteration) {
                // No predecessor iteration when there is a primary. Highlight as error
                predecessorIterationName = Constants.LABEL.UNSCHEDULED;
                colorClass = Constants.CLASS.ERROR;
            }
            else if (predecessorIteration && !primaryIteration) {
                // Predecessor but no primary, don't highlight the iteration name
                predecessorIterationName = predecessorIteration.Name;
            }
            else if (!predecessorIteration && !primaryIteration) {
                // display nothing
                predecessorIterationName = '';
            }

            result = this.colorsRenderer(predecessorIterationName, colorClass);
        }

        return result;
    },

    successorIterationRenderer: function(row, timeboxField) {
        var result;
        var startDateField = this.getStartDateField(timeboxField);
        var primaryStory = row.get(Constants.ID.STORY);
        var dependency = row.get(Constants.ID.SUCCESSOR);

        if (dependency) {
            var colorClass = Constants.CLASS.OK;
            var primaryIteration = primaryStory.get(timeboxField);
            var dependencyIteration = dependency.get(timeboxField);

            var dependencyIterationName;

            if (dependencyIteration && primaryIteration) {
                dependencyIterationName = dependencyIteration.Name;
                var primaryStartDate = primaryIteration[startDateField];
                var dependencyStartDate = dependencyIteration[startDateField];

                if (dependencyStartDate > primaryStartDate) {
                    // dependency scheduled before primary. OK
                }
                else if (dependencyStartDate == primaryStartDate) {
                    // dependency scheduled in same iteration as primary. Warn
                    colorClass = Constants.CLASS.WARNING;
                }
                else {
                    // dependency scheduled after primary (or not scheduled). Error
                    colorClass = Constants.CLASS.ERROR;
                }
            }
            else if (!dependencyIteration && primaryIteration) {
                // No dependency iteration when there is a primary. Highlight as error
                dependencyIterationName = Constants.LABEL.UNSCHEDULED;
                colorClass = Constants.CLASS.UNKNOWN;
            }
            else if (dependencyIteration && !primaryIteration) {
                // dependency but no primary, don't highlight the iteration name
                dependencyIterationName = dependencyIteration.Name;
            }
            else if (!dependencyIteration && !primaryIteration) {
                // display nothing
                dependencyIterationName = '';
            }

            result = this.colorsRenderer(dependencyIterationName, colorClass);
        }

        return result;
    },

    /**
     * value: String to display
     * cls: Extra class to add to the cell
     */
    colorsRenderer: function(value, cls) {
        return '<div class="status-color ' + cls + '">' + value + '</div>';
    },

    getSettingsFields: function() {
        var store = Ext.create('Rally.data.custom.Store', {
            data: [{
                Name: 'User Story',
                Value: Constants.SETTING.STORY,
            }, {
                Name: this.getLowestPortfolioItemTypeName(),
                Value: this.getLowestPortfolioItemTypeName()
            }]
        });
        return [{
            xtype: 'rallycombobox',
            name: Constants.SETTING.DEPENDENCY_TYPE,
            label: Constants.LABEL.DEPENDENCY_TYPE,
            displayField: 'Name',
            valueField: 'Value',
            store: store
        }];
    }
});


               Rally.launchApp('CArABU.app.TSApp', {
                   name: 'Story Dependency Schedule'
               });
        });
    </script>

    <style type="text/css">

.app {}

/* fix for grid hscroll when rows are tall and push hscroll off bottom of screen. Force it on */

.x-grid-body.x-panel-body {
    overflow-y: auto;
}

/* pills for status indicators */

.status-color {
    padding: 0 5px 0 5px;
    border-radius: 50px;
}

/* use the same colors as Agile Central for Late, At-Risk and Not Started */

.error {
    background-color: #F66349;
}

.warning {
    background-color: #FAD200;
}

.unknown {
    background-color: #E0E0E0;
}

/* visually divide rows into groups */

.group-separator {
    border-left: solid 2px rgb(213, 213, 213);
    border-right: solid 2px rgb(213, 213, 213);
}

/* highlight the group headers */

.x-group-header>.x-column-header-inner {
    background-color: rgb(213, 213, 213);
}

.alternate-row {
    background-color: rgb(244, 244, 244) !important;
}

.first-in-group {
    border-top: 1px solid rgb(186, 185, 186);
    /*border-bottom: 1px solid rgb(186, 185, 186);*/
}

.predecessor {
    border-top: 1px solid rgb(186, 185, 186);
    /*border-bottom: 1px solid rgb(186, 185, 186);*/
}

.successor {
    border-top: 1px solid rgb(186, 185, 186);
    /*border-bottom: 1px solid rgb(186, 185, 186);*/
}

.hidden {
    visibility: hidden;
}

    </style>

</head>
<body></body>
</html>